# 未命名文档

要让本地存储的象棋游戏数据（如历史战绩、复盘记录）“不易被篡改”，核心是通过 **数据结构化、完整性校验、加密存储** 三层防护实现，同时兼顾项目 “轻量化” 定位，避免引入复杂依赖。以下是具体方案设计：

## 一、核心改进方向：从 “明文 txt” 到 “结构化 + 校验存储”

原计划的 “txt 明文存储” 完全暴露数据，且无篡改校验，需先升级存储格式与校验逻辑，这是防篡改的基础。

### 1. 第一步：用 JSON/XML 实现数据结构化

**替换原 txt 明文存储**，改用 JSON（推荐，Java 原生支持且易读）或 XML 格式存储数据，明确字段定义，便于后续添加校验信息。

#### 示例：历史战绩的 JSON 结构（含校验字段）



```
{

&#x20; "battleRecord": {

&#x20;   "id": "20241022\_1530",  // 对战唯一标识（时间戳）

&#x20;   "redPlayer": "玩家A",

&#x20;   "blackPlayer": "玩家B",

&#x20;   "result": "red\_win",     // 结果：red\_win/black\_win/surrender

&#x20;   "duration": "15:30",     // 对战时长

&#x20;   "moveHistory": \["炮二平五", "马8进7", ...],  // 走法复盘记录

&#x20;   "createTime": "2024-10-22 15:30:00"

&#x20; },

&#x20; "antiTamper": {

&#x20;   "hashValue": "a1b2c3d4e5f6...",  // 数据哈希值（核心校验）

&#x20;   "salt": "x9y8z7..."              // 盐值（增强哈希安全性）

&#x20; }

}
```



* **优势**：字段清晰，可直接关联 “校验信息”，且 Java 可通过`org.json`包（轻量）或原生`Jackson`快速解析 / 生成。

### 2. 第二步：添加 “数据完整性校验”（防篡改核心）

通过 **哈希算法 + 盐值** 生成数据的 “唯一指纹”，存储时将指纹与数据绑定，读取时重新计算指纹对比 —— 若数据被篡改，指纹会不一致，直接判定数据无效。

#### 具体实现步骤：



1. **选择轻量哈希算法**：用 Java 原生`java.security.MessageDigest`实现 SHA-256（比 MD5 更安全，且原生支持，无需第三方库）。

2. **生成 “盐值”**：每次存储数据时，生成一个随机字符串（盐值，如 16 位随机数），与数据内容拼接后再计算哈希值 —— 避免 “相同数据生成相同哈希”，防止篡改者伪造。

3. **存储与校验逻辑**：

* **存储时**：

  ① 拼接 “数据内容 + 盐值” → ② 计算 SHA-256 哈希值 → ③ 将 “数据 + 盐值 + 哈希值” 一起存入 JSON 文件（如`battle_20241022_1530.json`）。

* **读取时**：

  ① 从 JSON 中读取 “数据内容、盐值、存储的哈希值” → ② 重新拼接 “数据内容 + 盐值” 并计算新哈希值 → ③ 对比 “新哈希值” 与 “存储的哈希值”：


  * 一致：数据未篡改，正常使用；

  * 不一致：数据被篡改，提示 “数据无效” 并跳过该记录。

#### 关键代码片段（Java 原生实现）：



```
import java.security.MessageDigest;

import java.security.SecureRandom;

import java.util.Base64;

// 生成随机盐值（16位）

public static String generateSalt() {

&#x20;   byte\[] salt = new byte\[16];

&#x20;   new SecureRandom().nextBytes(salt);

&#x20;   return Base64.getEncoder().encodeToString(salt);

}

// 计算数据+盐值的SHA-256哈希值

public static String calculateHash(String data, String salt) throws Exception {

&#x20;   String content = data + salt;  // 数据与盐值拼接

&#x20;   MessageDigest digest = MessageDigest.getInstance("SHA-256");

&#x20;   byte\[] hashBytes = digest.digest(content.getBytes("UTF-8"));

&#x20;   // 转为16进制字符串（便于存储）

&#x20;   StringBuilder hexHash = new StringBuilder();

&#x20;   for (byte b : hashBytes) {

&#x20;       hexHash.append(String.format("%02x", b));

&#x20;   }

&#x20;   return hexHash.toString();

}
```

## 二、进阶防护：加密存储（防止 “查看 + 篡改”）

若需进一步防止 “篡改者直接打开文件修改明文”，可对整个 JSON 文件进行 **对称加密**（适合轻量化项目，实现简单），读取时再解密。

### 1. 选择轻量对称加密算法：AES



* **优势**：Java 原生支持（`javax.crypto`包），加密强度足够，且加解密用同一密钥，实现简单。

* **密钥管理**：


  * 无需复杂密钥分发（本地存储场景），可将密钥 “硬编码 + 简单混淆”（如拆分密钥为两部分，代码中拼接）—— 虽非绝对安全，但能阻挡 90% 以上的普通篡改（专业黑客不在防护范围内，项目定位无需过度安全）。

  * 示例：密钥拆分为`"chessGameKeyPart1_"`和`"_Part22024"`，使用时拼接为`"chessGameKeyPart1__Part22024"`。

### 2. 加密 / 解密逻辑（核心步骤）：



1. **存储时（加密）**：

   ① 生成 JSON 字符串（含数据 + 哈希 + 盐值） → ② 用 AES 加密 JSON 字符串 → ③ 将加密后的字节数组存入文件（如`battle_20241022_1530.enc`，后缀改为`.enc`区分普通文件）。

2. **读取时（解密）**：

   ① 读取`.enc`文件的加密字节数组 → ② 用 AES 解密得到原始 JSON 字符串 → ③ 后续执行 “哈希校验” 逻辑。

## 三、辅助防护：文件权限与存储路径优化

通过系统级文件权限限制，减少 “误操作或恶意删除 / 修改” 的可能性，属于低成本补充防护。



1. **设置文件只读属性**：

   Java 中可通过`java.io``.File`类设置文件为 “只读”，存储完成后调用：



```
File recordFile = new File("data/battle\_20241022\_1530.enc");

recordFile.setReadOnly();  // 设置为只读，用户需手动修改权限才能篡改
```



* 注意：只读属性可被用户手动取消（如 Windows 右键 “属性” 取消只读），但能增加篡改门槛。

1. **隐藏存储路径**：

   将数据文件存放在系统 “隐藏目录” 下（如 Windows 的`C:\Users\用户名\AppData\Roaming\ChessGameData`，Linux 的`~/.chessGameData`），而非项目根目录 —— 普通用户不易找到文件，减少误改概率。

## 四、方案优先级与落地建议

考虑到项目 “轻量化 + 开发效率” 优先，建议按以下优先级逐步实现：



| 优先级   | 方案                            | 实现难度              | 防护效果                 | 核心目标                      |
| ----- | ----------------------------- | ----------------- | -------------------- | ------------------------- |
| 1（必做） | 结构化 JSON + 哈希校验（SHA-256 + 盐值） | 低（Java 原生支持，代码量少） | 核心防篡改：数据被改即能识别       | 确保数据有效性，杜绝 “篡改后正常读取”      |
| 2（可选） | AES 对称加密存储                    | 中（需理解加密流程，代码量中等）  | 增强防护：文件打开是乱码，无法直接改明文 | 防止 “查看 + 篡改”，适合对安全性有要求的场景 |
| 3（辅助） | 文件只读 + 隐藏路径                   | 低（API 调用简单）       | 补充防护：增加篡改操作门槛        | 减少普通用户误操作或初级篡改            |

## 五、关键注意事项



1. **避免过度设计**：不推荐使用非对称加密（如 RSA）或复杂密钥管理（如密钥存在系统密钥库），会大幅增加开发成本，与 “轻量化游戏” 定位不符。

2. **错误处理**：读取数据时若 “哈希不一致” 或 “解密失败”，需明确提示用户 “数据已篡改或损坏”，并跳过无效数据，避免程序崩溃。

3. **兼容性**：确保加密 / 哈希算法的 Java 版本兼容性（SHA-256、AES 在 Java 8 及以上均原生支持，无需担心版本问题）。

通过以上改造，本地存储的数据能实现 “不易被篡改” 的目标，同时兼顾开发难度，符合项目现阶段 “完成比完美更重要” 的核心原则。