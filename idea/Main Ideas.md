# Java 象棋对战游戏项目 Idea 文档

## 一、项目概述

### 1. 项目定位

一款**轻量化象棋对战游戏**，聚焦核心对弈体验，优先实现单机双人功能，后续可扩展局域网联机与人机对战，技术选型以 “简单易实现、符合学习阶段” 为原则，避免过度复杂设计。

### 2. 核心目标



* 完成 “可运行的单机双人象棋对战” 核心功能，满足基础对弈需求；

* 采用 MVC 架构实现逻辑与界面解耦，便于后续功能扩展与测试；

* 使用 Swing 开发 UI，兼顾开发难度与轻量化需求，避免引入 JavaFX（复杂）或 AWT（老旧）。

## 二、核心功能模块

### 1. 入口大厅界面



* **核心选项**：提供「双人单机对战」「局域网联机对战」两个核心入口（局域网联机为后续扩展，优先实现单机）；

* **辅助功能**：可加入「历史战绩查看」入口，展示过往对战结果与复盘记录。

### 2. 对弈界面



* **棋盘与棋子**：渲染标准象棋棋盘，棋子区分红黑双方，支持鼠标选中操作；

* **高亮提示**：选中棋子后，自动高亮显示该棋子可移动的合法位置；

* **将军提示**：当一方 “将军” 时，在屏幕显著位置（如顶部 / 底部）弹出提示（如 “红方将军！”）；

* **吃子显示**：被吃掉的棋子统一放置在界面侧边（红方吃子区 / 黑方吃子区），直观展示对战进度。

### 3. 对战辅助功能



* **计时功能**：为红黑双方分别添加计时器，支持计时暂停 / 重置（可选：超时自动判负）；

* **投降功能**：提供 “投降” 按钮，点击后弹出提示框：「“一个人可以被毁灭，但不可被击败”，你确定要投降吗？」，确认后触发 “帅 / 将自爆” 动画（参考炉石传说风格），并跳转失败结算页；

* **悔棋功能**：仅支持近期步数回退（如最多回退 5 步），通过 Controller 调用 Model 的历史记录接口实现，避免直接修改 Model 数据；

* **复盘功能**：对战结束后，可在 “历史战绩” 中查看该场对战的逐步回放，重现每一步走法。

### 4. 结算页面



* **胜利结算页**：展示获胜方（如 “红方获胜！”）、对战时长、步数统计，提供「返回大厅」「查看复盘」按钮；

* **失败结算页**：展示失败原因（如 “主动投降”“超时判负”），提供「返回大厅」「重新对战」按钮；

* *注：暂不实现 “和棋判定”*，因逻辑复杂且演示场景中大概率不会触发，优先保证核心功能落地。

## 三、技术架构设计

采用 **MVC 三层架构**，实现逻辑解耦，便于开发与后续扩展：



| 层级                  | 职责说明                        | 核心模块 / 接口                                                                                                                                                                                             |
| ------------------- | --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Model（模型层）**      | 封装核心业务逻辑，与界面无关，仅处理数据与规则     | 1. 棋盘类：维护棋盘状态（棋子位置、红黑方）；2. 棋子类：定义棋子类型（帅 / 将、车、马等）与合法走法；3. 规则类：实现胜负判断（将军、将死）、吃子逻辑、悔棋历史记录；4. 核心接口：   - `getCurrentBoardState()`：获取当前棋盘状态（供 View 渲染）；   - `executeMove()`：执行下一步走法（接收 Controller 传递的用户操作） |
| **View（视图层）**       | 仅负责 UI 渲染与用户输入捕获，不包含业务逻辑    | 1. 界面组件：Swing 实现大厅、对弈、结算页面；2. 渲染逻辑：根据 Model 返回的棋盘状态更新界面（棋子位置、高亮提示）；3. 输入处理：捕获鼠标点击（选中棋子、移动棋子）、按钮点击（投降、悔棋），传递给 Controller                                                                               |
| **Controller（控制层）** | 作为中介，协调 View 与 Model，处理交互逻辑 | 1. 操作转发：将 View 捕获的用户操作（如 “移动棋子”）转换为 Model 可识别的指令，调用 `executeMove()`；2. 状态同步：Model 逻辑执行后（如胜负判定），通知 View 刷新界面（如跳转结算页）；3. 功能协调：悔棋、复盘等功能，通过调用 Model 的历史记录接口 + 通知 View 刷新实现                                |

## 四、开发计划与优先级

### 1. 第一阶段：核心功能落地（优先级最高）



* 学习 Swing 核心组件（窗口、按钮、面板、鼠标事件），完成基础 UI 开发；

* 搭建 MVC 框架，实现 Model 层核心逻辑（棋盘、棋子、基本走法、胜负判断）；

* 开发「双人单机对战」全流程：大厅 → 对弈界面（棋子选中、高亮提示）→ 胜负结算。

### 2. 第二阶段：辅助功能完善（优先级中）



* 实现计时功能、投降功能（含提示框与自爆动画）；

* 开发悔棋功能与历史战绩存储（本地存储，如 txt 文件）；

* 优化 UI 细节（如棋子样式、界面布局，暂不追求动效）。

### 3. 第三阶段：扩展功能（优先级低，视时间精力而定）



* 实现局域网联机功能（基于 Socket 通信，简化版：仅支持同一局域网内连接）；

* 开发人机对战插件（仅实现 Easy 难度）：基于简单算法（如随机合法走法），通过预留的 `getCurrentBoardState()` 和 `executeMove()` 接口接入，不涉及复杂 AI 模型。

## 五、关键技术选型说明



| 技术点   | 选型结果          | 选型理由                                                                                                            |
| ----- | ------------- | --------------------------------------------------------------------------------------------------------------- |
| UI 框架 | Swing         | 1. 轻量化，适合小游戏开发；2. 学习成本低于 JavaFX，文档资源丰富；3. 避免使用 AWT（功能老旧，无 Swing 易用）与 JavaFX（架构复杂，适合大型项目）                        |
| 架构模式  | MVC           | 1. 解耦业务逻辑与界面，便于单元测试（如单独测试 Model 的胜负判断）；2. 后续扩展人机对战、联机功能时，无需大幅修改现有代码；3. 符合 Java 开发规范，便于协作分工（如一人写 Model，一人写 View） |
| 数据存储  | .json | 1. 历史战绩与复盘数据量小，无需数据库；2. 开发难度低，避免引入额外技术（如 MySQL、Redis）4.加入SHA256 和盐值的检验防止篡改                                                           |

## 六、开发注意事项



1. **优先级原则**：坚持 “完成比完美更重要”，先实现核心对弈流程（单机双人），再优化细节（如动画、计时），最后考虑扩展功能（联机、人机）；

2. **避免过度设计**：不追求复杂功能（如和棋判定、高难度 AI），不引入未学习的技术（如 JavaFX、Spring），聚焦当前能力范围内的落地；

3. **协作分工**：基于 MVC 架构拆分任务，例如：一人负责 Model 层核心逻辑（棋盘、规则），一人负责 View 层 Swing 界面开发，Controller 层共同调试；

4. **预留扩展接口**：严格按照 Model 层的两个核心接口（`getCurrentBoardState()`、`executeMove()`）开发，为后续人机对战插件预留接入点，避免后期重构。